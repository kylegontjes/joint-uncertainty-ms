---
title: "Construct parent child dataset with transition statistics of all reconstructions"
author: "Kyle Gontjes"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
require(knitr) 
opts_knit$set(echo = TRUE,warning = FALSE, message = FALSE,error=FALSE,comment=NA) 
opts_chunk$set(echo = TRUE,warning = FALSE, message = FALSE,error=FALSE,comment=NA) 
knitr::opts_knit$set(root.dir = '/nfs/turbo/umms-esnitkin/Project_Penn_KPC/Analysis/Phyloaware/joint-uncertainty-ms') 
```

# Environmental 
```{r environment, echo=T, message=FALSE, include=T, results=T}
#Packages
packages <- c("dplyr",'phyloAMR','ape') 

#Load Packages
invisible(lapply(packages,library,character.only=T,quietly=T))

# Print environment
set.seed(0104) 
Sys.info()
sessionInfo()
```
 
# Load data
## Dataset and tree
```{r}  
phy <- ape::read.tree("./data/empirical/tree/tree.treefile")
dat <- readRDS("./data/empirical/dataset/df.RDS")
dat <- dat[match(phy$tip.label, dat[['isolate_no']]), ]
```
## Genotypes
```{r, load genotypes}
genotypes <- readRDS("./data/empirical/resistance_genotypes/resistance_genotypes.RDS") 
genotypes <-  genotypes %>% .[match(phy$tip.label,.[['isolate_no']]),]

df <- left_join(dat,genotypes)
df <- df[match(phy$tip.label, df[['isolate_no']]), ]
```
## Reconstructions
```{r, load reconstruction}
# Reconstructions 
joint_uncs <- readRDS("./data/empirical/joint_reconstruction/phenotype_genotype_joint_uncertainty_asrs.RDS")
# Names of traits
names_of_uncs <- names(joint_uncs)
```

# Generate  parent child dfs 
## Extract states
```{r, extract states} 
# Extract states
states <- lapply(names_of_uncs,FUN=function(name,focal,joint_uncs){ 
  # get states from joint_uncs
  joint_unc_states <-  lapply(joint_uncs[[name]]$sampled_joints,FUN=function(x){x[["anc.states"]]}) 
  names(joint_unc_states) <-  paste0("alt_recon_", seq_len(length(paste0("alt_recon_", seq_len(length(joint_unc_states))))))
  
  # Focal states
  joint_unc_states[['focal_states']] = joint_uncs[[name]]$best_joint$lik.anc.states
  return(joint_unc_states)
},focal = focals,joint_uncs = joint_uncs)  

names(states) <- names_of_uncs
```

## Get dataframe from ancestral states
```{r, get dataframe} 
# Internal function
get_parent_child_df_from_states <- function(states,dat,tr,feature,outcome_str){ 
  # Get Parent Child data from tree, states, and outcome string
  parent_child_df <- get_parent_child_data(tr=tr, ancestral_states=states, trait_data  = outcome_str, confidence_threshold  = NULL, node_states='joint')
  # Annotate parent child data
  parent_child_df <- get_continuation_data(parent_child_df, node_states = 'joint')
  return(parent_child_df)
}
```

## Parallelized parent child data frame construction
```{r, pcdf parallel}  
# Create a list of jobs
jobs <- do.call(c,
    lapply(names_of_uncs, function(name) {
        lapply(names(states[[name]]), function(state_name) {
            list(
                name = name,
                reconstruction = state_name
            )
        })
    })
)
## Randomly sample jobs
jobs <- jobs[sample(length(jobs))] 

# Chunk size and partitioning
chunk_size <- 500
job_chunks <- split(jobs, ceiling(seq_along(jobs) / chunk_size))

# Pre compute outcome strings to speed up analyses
outcome_strs <- lapply(names_of_uncs, function(name) {
  setNames(df[, name], df$isolate_no)
})
names(outcome_strs) <- names_of_uncs

# Generate a flat parent child dataframe list using job chunks
parent_child_flat <- pbmcapply::pbmclapply(
    job_chunks,
    function(chunk) {
      
  out <- vector("list", length(chunk))
   for (i in seq_along(chunk)) {
      # Get job info
      job <- chunk[[i]]
      name  <- job$name
      reconstruction <- job$reconstruction
      # Run command
      pcdf <- get_parent_child_df_from_states(
                states[[name]][[reconstruction]],
                dat = df,
                tr = phy,
                feature = name,
                outcome_str = outcome_strs[[name]]
            )
      # Annotate
      pcdf$trait <- name
      pcdf$reconstruction <- reconstruction
      # Store output
      out[[i]] <- pcdf 
    }
    out
    }, 
    mc.cores = 25
)

# Unlist this grouping
flat_list <- unlist(parent_child_flat, recursive = FALSE)
# Get job list information
all_jobs <- unlist(job_chunks, recursive = FALSE)
 
# Create final output structure
parent_child_dfs <- list()
# Preallocate outer list
parent_child_dfs <- setNames(vector("list", length(names_of_uncs)), names_of_uncs)
## Name the lists
for (nm in names_of_uncs) {
  state_names <- names(states[[nm]])
  parent_child_dfs[[nm]] <- setNames(vector("list", length(state_names)), state_names)
} 
## Allocate
for (i in seq_along(flat_list)) {
  job <- all_jobs[[i]]
  parent_child_dfs[[job$name]][[job$reconstruction]] <- flat_list[[i]]
}
```

## Save parent child dfs
```{r, save pcdfs}
saveRDS(parent_child_dfs,"./data/empirical/phyloAMR/joint_states_parent_child_dfs.RDS")
```

# Generate ASR transition data
```{r,transition_statistics} 
# Generate transition statistics
state_transition_statistics <- lapply(names_of_uncs,FUN=function(name){
  reconstructions <- parent_child_dfs[[name]]
  results <- pbmcapply::pbmclapply(reconstructions,asr_transition_analysis,node_states='joint',mc.cores = 25) 
  results <- do.call(rbind,results)
  results$reconstruction <- rownames(results)
  results$trait = name 
  return(results)
})  
names(state_transition_statistics) <- names_of_uncs

saveRDS(state_transition_statistics,"./data/empirical/phyloAMR/joint_states_reconstruction_transition_statistics.RDS")
```